# Default values for jfrog-platform.

# nameOverride:
# fullnameOverride:

# If this is an upgrade over an existing platform chart(>= 10.0.0), explicitly pass 'gaUpgradeReady=true' to upgrade
gaUpgradeReady: false

# If you are upgrading from a chart version(< 10.18.x) that has postgresql.image.tag of 13.x, make sure to set the current postgresql.image.tag to the same tag and databaseUpgradeReady=true.
# If you are upgrading from a chart version (>= 10.18.x), just set databaseUpgradeReady=true.
databaseUpgradeReady: false

global:
  # Allows skipping image verification, applicable to bitnami chart images only
  security:
    allowInsecureImages: true

  # imagePullSecrets:
  #   - myRegistryKeySecretName
  imageRegistry: releases-docker.jfrog.io
  jfrogUrl: '{{ include "jfrog-platform.jfrogUrl" . }}'
  joinKey: EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
  masterKey: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
  ## Chart.AppVersion for each product can be overidden using global.versions.<product>
  ## For example : For artifactory, using global.versions.artifactory
  ## Note: Order of preference is 1) global.versions 2) .Values.artifactory.image.tag 3) Chart.AppVersion
  versions: {}
  #   router:
  #   artifactory:
  #   xray:
  #   distribution:
  database:
    host: "{{ .Release.Name }}-postgresql"
    port: 5432
    sslMode: disable
    adminPassword: postgres
    secrets: {}
      # adminPassword:
      #   name: "jp-database-creds"
      #   key: "db-admin-password"
    initContainerSetupDBImage: "{{ .Values.global.imageRegistry }}/postgres:16.6-alpine"
    # Run the postgres init container as a non-default uid
    initContainerSetupDBUser:
    initContainerImagePullPolicy: IfNotPresent
    initContainerImageResources:
      requests:
        cpu: 5m
        memory: 10Mi
      limits:
        cpu: 1
        memory: 1Gi
    # If you are using external postgresql, set initDBCreation: false
    initDBCreation: true
  ## certificates added to this secret will be copied to $JFROG_HOME/<product>/var/etc/security/keys/trusted directory
  customCertificates:
    enabled: false
    # certificateSecretName:

  customInitContainersBegin: |
    {{ template "initdb" . }}
  customVolumes: |
    {{ template "initdb-volume" . }}

  rabbitmq:
    auth:
      tls:
        ## Please note: The below two lines SHOULD BE same as rabbitmq.auth.tls.enabled, rabbitmq.auth.tls.autoGenerated values in order to share the settings with Xray and Pipelines charts.
        # By default TLS certs are autogenerated, if you wish to add your own certs, please set this to false.
        enabled: false
        autoGenerated: true

        ## If you want to provide self generated certs as a secret, Uncomment the below line and provide the secret name.
        ## **NOTE**: Please uncomment line rabbitmq.auth.tls.existingSecret as well.
        # existingSecret:
  xray:
    # Rabbitmq settings that are specific to Xray
    rabbitmq:
      vhost: xray
      replicaCount: 1
      haQuorum:
        enabled: false
        waitForPreviousPodsOnInitialStartup: true
        vhost: xray_haq


## This Postgresql is used by all products , set postgresql.enabled: false, when you want to use external postgresql for all products
postgresql:
  enabled: true
  enablePostgresUser: true
  image:
    repository: bitnami/postgresql
    tag: 16.6.0-debian-12-r2
  auth:
    postgresPassword: "postgres"
  primary:
    extendedConfiguration: |
      max_connections = 1000
      max_wal_size = 1000MB
    persistence:
      size: 500Gi

  upgradeHookSTSDelete:
    enabled: true
    # Anotations are added to spec.metadata.annotations (applies to POD)
    annotations: {}

    # job.annotations are added to metadata.annotations (applies to JOB)
    job:
      annotations: {}
    image:
      registry: "{{ .Values.global.imageRegistry }}"
      repository: bitnami/kubectl
      tag: 1.31.2
      pullPolicy: IfNotPresent
    resources:
      requests:
        cpu: 5m
        memory: 10Mi
      limits:
        cpu: 0.5
        memory: 1Gi
    tolerations: []
    ## Service account for the pre-upgrade hook to perform rabbitmq migration
    serviceAccount:
      create: true
      ## The name of the ServiceAccount to use.
      ## If not set and create is true, a name is generated using the fullname template
      name:
      ## Explicitly mounts the API credentials for the Service Account
      automountServiceAccountToken: true
      rbac:
        create: true
        role:
          ## Rules to create. It follows the role specification
          rules:
            - apiGroups:
                - "apps"
              resources:
                - statefulsets
              verbs:
                - get
                - delete
                - list

## This Rabbitmq is used by Xray and Pipelines only, set rabbitmq.enabled: false, when Xray or Pipelines is not enabled
rabbitmq:
  enabled: true
  ## Enable the flag if the feature flags in rabbitmq is enabled manually
  rabbitmqUpgradeReady: false
  replicaCount: 1
  image:
    repository: bitnami/rabbitmq
    tag: 3.13.7-debian-12-r6
  extraPlugins: "rabbitmq_management"
  auth:
  ## Enable encryption to rabbitmq
  ## ref: https://www.rabbitmq.com/ssl.html
  ##
    tls:
      ## Please note that the below two lines SHOULD BE same as global.rabbitmq.auth.tls.enabled,global.rabbitmq.auth.tls.autoGenerated values in order to share the settings with Xray and Pipelines charts.
      enabled: false
      autoGenerated: true
      failIfNoPeerCert: false
      sslOptionsVerify: verify_peer
      failIfNoCert: false
      sslOptionsPassword:
        enabled: false
        existingSecret: ""
        key: ""
        password: ""
      caCertificate:
      serverCertificate:
      serverKey:

      ## Uncomment the below line ONLY IF you provided self generated certs as a secret in global section.
      # existingSecret: '{{ .Values.global.rabbitmq.auth.tls.existingSecret }}'
      existingSecretFullChain: false
      overrideCaCertificate: ""
    username: admin
    password: password
    erlangCookie: secretcookie
    ## Alternatively, you can use a pre-existing secret with a key called rabbitmq-password by specifying existingPasswordSecret.
    ## By default, the secret name '{{ .Release.Name }}-xray-rabbitmq-creds' will be used and passed to the Xray section as an external RabbitMQ. Please avoid using the same name.
    # existingPasswordSecret: <name-of-existing-secret>
  ## To support upgrade from 3.8.x to 3.11.x , featureFlags are needed
  ## ref: https://blog.rabbitmq.com/posts/2022/07/required-feature-flags-in-rabbitmq-3.11/
  featureFlags: drop_unroutable_metric,empty_basic_get_metric,implicit_default_bindings,maintenance_mode_status,quorum_queue,stream_queue,user_limits,virtual_host_metadata
  maxAvailableSchedulers: null
  onlineSchedulers: null
  persistence:
    size: 50Gi
  tolerations: []
  extraEnvVars:
    - name: RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS
      value: "+S 2:2 +sbwt none +sbwtdcpu none +sbwtdio none"
  ## Specifies the name of an existing Kubernetes Secret containing the RabbitMQ definition.
  # The chart will create a secret named '{{ .Release.Name }}-load-definition' and load the definition from the file `files/load_definition.json`.
  loadDefinition:
    enabled: true
    existingSecret: '{{ .Release.Name }}-load-definition'
  ## Upgrade of rabbitmq from 3.8.x to 3.11.x needs the feature flags to be enabled.
  ## Ref: (https://blog.rabbitmq.com/posts/2022/07/required-feature-flags-in-rabbitmq-3.11/
  ## migration enable will perform `rabbitmqctl enable_feature_flag all` command on the existing rabbitmq before starting the upgrade
  migration:
    ## Migration is required to be performed only once hence this option can be disabled once the feature flags are enabled in rabbitmq.
    enabled: true
    # Anotations are added to spec.metadata.annotations (applies to POD)
    annotations: {}

    # job.annotations are added to metadata.annotations (applies to JOB)
    job:
      annotations: {}
    ## Another uses of migration hook are:
    ## - Deleting StatefulSet for allowing updating certain fields that require it:
    ##   Changing podManagementPolicy OrderedReady -> Parallel requires deleting stateful set
    ## - Deleting ha-all mirror policy on migrating to Quorum Queues
    deleteStatefulSetToAllowFieldUpdate:
      enabled: false
    removeHaPolicyOnMigrationToHaQuorum:
      enabled: false
    image:
      registry: "{{ .Values.global.imageRegistry }}"
      repository: bitnami/kubectl
      tag: 1.31.2
      pullPolicy: IfNotPresent
    resources:
      requests:
        cpu: 5m
        memory: 10Mi
      limits:
        cpu: 1
        memory: 1Gi
    ## Service account for the pre-upgrade hook to perform rabbitmq migration
    serviceAccount:
      create: true
      ## The name of the ServiceAccount to use.
      ## If not set and create is true, a name is generated using the fullname template
      name:
      ## Explicitly mounts the API credentials for the Service Account
      automountServiceAccountToken: true
      rbac:
        create: true
        role:
          ## Rules to create. It follows the role specification
          rules:
            - apiGroups:
                - ""
              resources:
                - pods/exec
                - pods
              verbs:
                - create
                - get
                - list
            - apiGroups:
                - "apps"
              resources:
                - statefulsets
              verbs:
                - get
                - list
                - delete

  extraConfiguration: |-
    management.listener.ssl = {{ .Values.global.rabbitmq.auth.tls.enabled }}

  initContainers: |
    {{ template "waitForPreviousPods" . }}

artifactory:
  enabled: true
  unifiedUpgradeAllowed: true
  installerInfo: '{"productId":"Helm_JFrogPlatform/{{ printf "11.1.8-%s" .Chart.AppVersion  }}","features":[{"featureId":"Platform/{{ printf "%s-%s" "kubernetes" .Capabilities.KubeVersion.Version }}"},{"featureId":"Database/{{ .Values.database.type }}"},{"featureId":"Nginx_Enabled/{{ .Values.nginx.enabled }}"},{"featureId":"ArtifactoryPersistence_Type/{{ .Values.artifactory.persistence.type }}"},{"featureId":"SplitServicesToContainers_Enabled/{{ .Values.splitServicesToContainers }}"},{"featureId":"Filebeat_Enabled/{{ .Values.filebeat.enabled }}"},{"featureId":"ReplicaCount/{{ .Values.artifactory.replicaCount }}"}]}'
  postgresql:
    enabled: false
  waitForDatabase: false
  database:
    type: postgresql
    driver: org.postgresql.Driver
    url: '{{ include "database.url" . }}'
    user: artifactory
    password: artifactory
  # Note: For artifactory Pro license, mission-control is not supported, Hence, set mc.enabled: false
  # Note: mission-control is disabled by default, this is only available for E+ customers, and can be enabled by setting mc.enabled: true
  mc:
    enabled: false
  artifactory:
    worker:
      enabled: '{{ .Values.worker.enabled }}'
    unifiedSecretInstallation: true
    ## unifiedSecretPrependReleaseName Set this flag to false if unifiedSecret should not be created with <release-name> prepended.
    unifiedSecretPrependReleaseName: true
    # Note: For HA deployments, set replicaCount >1 (recommended 3)
    replicaCount: 1
    migration:
      enabled: false
    persistence:
      size: 200Gi
    # license:
    #   secret:
    #   dataKey:

xray:
  enabled: true
  unifiedUpgradeAllowed: true
  xray:
    unifiedSecretInstallation: true
  postgresql:
    enabled: false
  database:
    url: '{{ include "database.url" . }}'
    user: xray
    password: xray
  common:
    persistence:
      size: 200Gi
    rabbitmq:
      connectionConfigFromEnvironment: false
    extraEnvVars: |
      {{- if not .Values.global.xray.rabbitmq.haQuorum.enabled }}
      - name: "JF_SHARED_RABBITMQ_VHOST"
        value: "xray"
      {{- end }}
  rabbitmq:
    enabled: false
    external:
      erlangCookie: secretcookie
      ## The chart will create a secret from the JFrog platform-specific RabbitMQ parameters and will use this secret to enable Xray to connect with RabbitMQ.
      ## By default, the secret name will be '{{ .Release.Name }}-xray-rabbitmq-creds' and it will be passed to Xray as an external RabbitMQ.
      secrets:
        username:
          name: '{{ .Release.Name }}-xray-rabbitmq-creds'
          key: "username"
        password:
          name: '{{ .Release.Name }}-xray-rabbitmq-creds'
          key: "password"
        url:
          name: '{{ .Release.Name }}-xray-rabbitmq-creds'
          key: "url"
  ## To enable JFrog Advanced Security(JAS), uncomment below section
  ## https://jfrog.com/help/r/jfrog-installation-setup-documentation/install-jfrog-advanced-security-on-your-self-hosted-environment-with-helm
  # serviceAccount:
  #   create: true
  # rbac:
  #   create: true

catalog:
  enabled: false
  database:
    url: '{{ include "database.url" . }}'
    user: catalog
    password: catalog

distribution:
  enabled: false
  unifiedUpgradeAllowed: true
  distribution:
    unifiedSecretInstallation: true
  postgresql:
    enabled: false
  database:
    url: '{{ include "database.url" . }}'
    user: distribution
    password: distribution

worker:
  enabled: false

preUpgradeHook:
  ## This is required to be performed to check if existing products like distribution already exists
  enabled: true
  # Anotations are added to spec.metadata.annotations (applies to POD)
  annotations: {}

  # job.annotations are added to metadata.annotations (applies to JOB)
  job:
    annotations: {}
  image:
    registry: "{{ .Values.global.imageRegistry }}"
    repository: bitnami/kubectl
    tag: 1.31.2
    pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: 5m
      memory: 10Mi
    limits:
      cpu: 1
      memory: 1Gi
  tolerations: []
  podSecurityContext:
    enabled: false
  containerSecurityContext:
    enabled: false
