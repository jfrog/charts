# Default values for jfrog-platform.

# nameOverride:
# fullnameOverride:

# If this is an upgrade over an existing platform chart(>= 10.0.0), explicitly pass 'gaUpgradeReady=true' to upgrade
gaUpgradeReady: false

# If you are upgrading from a chart version(< 10.18.x) that has postgresql.image.tag of 13.x, make sure to set the current postgresql.image.tag to the same tag and databaseUpgradeReady=true.
# If you are upgrading from a chart version (>= 10.18.x), just set databaseUpgradeReady=true.
databaseUpgradeReady: false

global:
  # imagePullSecrets:
  #   - myRegistryKeySecretName
  imageRegistry: releases-docker.jfrog.io
  jfrogUrl: '{{ include "jfrog-platform.jfrogUrl" . }}'
  joinKey: EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
  masterKey: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
  ## Chart.AppVersion for each product can be overidden using global.versions.<product>
  ## For example : For artifactory, using global.versions.artifactory
  ## Note: Order of preference is 1) global.versions 2) .Values.artifactory.image.tag 3) Chart.AppVersion
  versions: {}
  #   router:
  #   artifactory:
  #   xray:
  #   distribution:
  database:
    host: "{{ .Release.Name }}-postgresql"
    port: 5432
    sslMode: disable
    adminPassword: postgres
    secrets: {}
      # adminPassword:
      #   name: "jp-database-creds"
      #   key: "db-admin-password"
    initContainerSetupDBImage: "{{ .Values.global.imageRegistry }}/postgres:16.6-alpine"
    # Run the postgres init container as a non-default uid
    initContainerSetupDBUser:
    initContainerImagePullPolicy: IfNotPresent
    initContainerImageResources:
      requests:
        cpu: 5m
        memory: 10Mi
      limits:
        cpu: 1
        memory: 1Gi
    # If you are using external postgresql, set initDBCreation: false
    initDBCreation: true
  ## certificates added to this secret will be copied to $JFROG_HOME/<product>/var/etc/security/keys/trusted directory
  customCertificates:
    enabled: false
    # certificateSecretName:

  customInitContainersBegin: |
    {{ template "initdb" . }}
  customVolumes: |
    {{ template "initdb-volume" . }}

  rabbitmq:
    auth:
      tls:
        ## Please note: The below two lines SHOULD BE same as rabbitmq.auth.tls.enabled, rabbitmq.auth.tls.autoGenerated values in order to share the settings with Xray and Pipelines charts.
        # By default TLS certs are autogenerated, if you wish to add your own certs, please set this to false.
        enabled: false
        autoGenerated: true

        ## If you want to provide self generated certs as a secret, Uncomment the below line and provide the secret name.
        ## **NOTE**: Please uncomment line rabbitmq.auth.tls.existingSecret as well.
        # existingSecret:

## This Postgresql is used by all products , set postgresql.enabled: false, when you want to use external postgresql for all products
postgresql:
  enabled: true
  enablePostgresUser: true
  image:
    repository: bitnami/postgresql
    tag: 16.6.0-debian-12-r2
  auth:
    postgresPassword: "postgres"
  primary:
    extendedConfiguration: |
      max_connections = 1000
      max_wal_size = 1000MB
    persistence:
      size: 500Gi

  upgradeHookSTSDelete:
    enabled: true
    image:
      registry: "{{ .Values.global.imageRegistry }}"
      repository: bitnami/kubectl
      tag: 1.31.2
      pullPolicy: IfNotPresent
    resources:
      requests:
        cpu: 5m
        memory: 10Mi
      limits:
        cpu: 0.5
        memory: 1Gi
    tolerations: []
    ## Service account for the pre-upgrade hook to perform rabbitmq migration
    serviceAccount:
      create: true
      ## The name of the ServiceAccount to use.
      ## If not set and create is true, a name is generated using the fullname template
      name:
      ## Explicitly mounts the API credentials for the Service Account
      automountServiceAccountToken: true
      rbac:
        create: true
        role:
          ## Rules to create. It follows the role specification
          rules:
            - apiGroups:
                - "apps"
              resources:
                - statefulsets
              verbs:
                - get
                - delete
                - list

## This Rabbitmq is used by Xray and Pipelines only, set rabbitmq.enabled: false, when Xray or Pipelines is not enabled
rabbitmq:
  enabled: true
  ## Enable the flag if the feature flags in rabbitmq is enabled manually
  rabbitmqUpgradeReady: false
  image:
    repository: bitnami/rabbitmq
    tag: 3.13.7-debian-12-r2
  auth:
  ## Enable encryption to rabbitmq
  ## ref: https://www.rabbitmq.com/ssl.html
  ##
    tls:
      ## Please note that the below two lines SHOULD BE same as global.rabbitmq.auth.tls.enabled,global.rabbitmq.auth.tls.autoGenerated values in order to share the settings with Xray and Pipelines charts.
      enabled: false
      autoGenerated: true
      failIfNoPeerCert: false
      sslOptionsVerify: verify_peer
      failIfNoCert: false
      sslOptionsPassword:
        enabled: false
        existingSecret: ""
        key: ""
        password: ""
      caCertificate:
      serverCertificate:
      serverKey:

      ## Uncomment the below line ONLY IF you provided self generated certs as a secret in global section.
      # existingSecret: '{{ .Values.global.rabbitmq.auth.tls.existingSecret }}'
      existingSecretFullChain: false
      overrideCaCertificate: ""
    username: admin
    password: password
    erlangCookie: secretcookie
  ## To support upgrade from 3.8.x to 3.11.x , featureFlags are needed
  ## ref: https://blog.rabbitmq.com/posts/2022/07/required-feature-flags-in-rabbitmq-3.11/
  featureFlags: drop_unroutable_metric,empty_basic_get_metric,implicit_default_bindings,maintenance_mode_status,quorum_queue,stream_queue,user_limits,virtual_host_metadata
  maxAvailableSchedulers: null
  onlineSchedulers: null
  persistence:
    size: 50Gi
  tolerations: []
  extraEnvVars:
    - name: RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS
      value: "+S 2:2 +sbwt none +sbwtdcpu none +sbwtdio none"
  extraSecretsPrependReleaseName: true
  extraSecrets:
    load-definition:
      load_definition.json: |
        {
          "vhosts": [
            {
              "name": "xray"
            }
          ],
          "users": [
            {
              "name": "{{ .Values.auth.username }}",
              "password": "{{ .Values.auth.password }}",
              "tags": "administrator"
            }
          ],
          "permissions": [
          {
            "user": "admin",
            "vhost": "xray",
            "configure": ".*",
            "write": ".*",
            "read": ".*"
          }
          ],
          "policies": [
            {
              "name": "ha-all",
              "apply-to": "all",
              "pattern": ".*",
              "vhost": "xray",
              "definition": {
                "ha-mode": "all",
                "ha-sync-mode": "automatic"
              }
            }
          ]
        }
  loadDefinition:
    enabled: true
    existingSecret: '{{ .Release.Name }}-load-definition'
  ## Upgrade of rabbitmq from 3.8.x to 3.11.x needs the feature flags to be enabled.
  ## Ref: (https://blog.rabbitmq.com/posts/2022/07/required-feature-flags-in-rabbitmq-3.11/
  ## migration enable will perform `rabbitmqctl enable_feature_flag all` command on the existing rabbitmq before starting the upgrade
  migration:
    ## Migration is required to be performed only once hence this option can be disabled once the feature flags are enabled in rabbitmq.
    enabled: true
    image:
      registry: "{{ .Values.global.imageRegistry }}"
      repository: bitnami/kubectl
      tag: 1.31.2
      pullPolicy: IfNotPresent
    resources:
      requests:
        cpu: 5m
        memory: 10Mi
      limits:
        cpu: 1
        memory: 1Gi
    ## Service account for the pre-upgrade hook to perform rabbitmq migration
    serviceAccount:
      create: true
      ## The name of the ServiceAccount to use.
      ## If not set and create is true, a name is generated using the fullname template
      name:
      ## Explicitly mounts the API credentials for the Service Account
      automountServiceAccountToken: true
      rbac:
        create: true
        role:
          ## Rules to create. It follows the role specification
          rules:
            - apiGroups:
                - ""
              resources:
                - pods/exec
                - pods
              verbs:
                - create
                - get
                - list

  extraConfiguration: |-
    management.listener.ssl = {{ .Values.global.rabbitmq.auth.tls.enabled }}

artifactory:
  enabled: true
  unifiedUpgradeAllowed: true
  installerInfo: '{"productId":"Helm_JFrogPlatform/{{ printf "11.0.1-%s" .Chart.AppVersion  }}","features":[{"featureId":"Platform/{{ printf "%s-%s" "kubernetes" .Capabilities.KubeVersion.Version }}"},{"featureId":"Database/{{ .Values.database.type }}"},{"featureId":"Nginx_Enabled/{{ .Values.nginx.enabled }}"},{"featureId":"ArtifactoryPersistence_Type/{{ .Values.artifactory.persistence.type }}"},{"featureId":"SplitServicesToContainers_Enabled/{{ .Values.splitServicesToContainers }}"},{"featureId":"Filebeat_Enabled/{{ .Values.filebeat.enabled }}"},{"featureId":"ReplicaCount/{{ .Values.artifactory.replicaCount }}"}]}'
  postgresql:
    enabled: false
  waitForDatabase: false
  database:
    type: postgresql
    driver: org.postgresql.Driver
    url: '{{ include "database.url" . }}'
    user: artifactory
    password: artifactory
  # Note: For artifactory Pro license, mission-control is not supported, Hence, set mc.enabled: false
  # Note: mission-control is disabled by default, this is only available for E+ customers, and can be enabled by setting mc.enabled: true
  mc:
    enabled: false
  artifactory:
    worker:
      enabled: '{{ .Values.worker.enabled }}'
    unifiedSecretInstallation: true
    ## unifiedSecretPrependReleaseName Set this flag to false if unifiedSecret should not be created with <release-name> prepended.
    unifiedSecretPrependReleaseName: true
    # Note: For HA deployments, set replicaCount >1 (recommended 3)
    replicaCount: 1
    migration:
      enabled: false
    persistence:
      size: 200Gi
    # license:
    #   secret:
    #   dataKey:

xray:
  enabled: true
  unifiedUpgradeAllowed: true
  xray:
    unifiedSecretInstallation: true
  postgresql:
    enabled: false
  database:
    url: '{{ include "database.url" . }}'
    user: xray
    password: xray
  common:
    persistence:
      size: 200Gi
    rabbitmq:
      connectionConfigFromEnvironment: false
    extraEnvVars: |
      - name: "JF_SHARED_RABBITMQ_VHOST"
        value: "xray"
  rabbitmq:
    enabled: false
    external:
      username: admin
      password: password
      url: '{{ include "xray.rabbitmq.extRabbitmq.url" . }}'
      erlangCookie: secretcookie

catalog:
  enabled: false
  database:
    url: '{{ include "database.url" . }}'
    user: catalog
    password: catalog

distribution:
  enabled: false
  unifiedUpgradeAllowed: true
  distribution:
    unifiedSecretInstallation: true
  postgresql:
    enabled: false
  database:
    url: '{{ include "database.url" . }}'
    user: distribution
    password: distribution

worker:
  enabled: false

preUpgradeHook:
  ## This is required to be performed to check if existing products like distribution already exists
  enabled: true
  image:
    registry: "{{ .Values.global.imageRegistry }}"
    repository: bitnami/kubectl
    tag: 1.31.2
    pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: 5m
      memory: 10Mi
    limits:
      cpu: 1
      memory: 1Gi
  tolerations: []
  podSecurityContext:
    enabled: false
  containerSecurityContext:
    enabled: false
